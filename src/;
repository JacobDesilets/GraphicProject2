class Object {

  constructor(gl, points, vert, frag) {
    this.gl = gl;
    this.points = points;
    this.program = initShaders(this.gl, vert, frag);

    this.gl.useProgram(this.program)

    this.Ibuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.Ibuffer);
    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.points.indexList), this.gl.STATIC_DRAW);

    this.Vbuffer = gl.createBuffer();
    this.gl.bindBuffer(gl.ARRAY_BUFFER, this.Vbuffer);
    this.gl.bufferData(gl.ARRAY_BUFFER, flatten(this.points.vertices), this.gl.STATIC_DRAW);

    this.Vpointer = this.gl.getAttribLocation(this.program, "vertexPosition");
    this.gl.vertexAttribPointer(this.Vpointer, 4, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.Vpointer);

  }

  projection(M) {
    this.gl.useProgram(this.program);
    this.modelviewLocation = gl.getUniformLocation(this.program, "modelview");
    this.projectionLocation = gl.getUniformLocation(this.program, "projection");
    this.gl.uniformMatrix4fv(this.modelviewLocation, false, M);
  }

  lighting() {

    this.gl.useProgram(this.program);

    this.faceNormals = getFaceNormals(this.points.vertices, this.points.indexList, this.points.indexList.length / 3);

    let vertexNormals = getVertexNormals(this.points.vertices, this.points.indexList, this.faceNormals, this.points.vertices.length, this.points.indexList.length / 3);

    this.Nbuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.Nbuffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, flatten(vertexNormals), this.gl.STATIC_DRAW);

    this.vertexNormal = this.gl.getAttribLocation(this.program, "vertexNormal");
    this.gl.vertexAttribPointer(this.vertexNormal, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.vertexNormal);

    let ka = vec3(.9, .9, .9);
    let kd = vec3(.9, .9, .9);
    let ks = vec3(1.0, 1.0, 1.0);
    let shininess = 0.1;

    this.gl.uniform3f(this.gl.getUniformLocation(this.program, "ka"), ka[0], ka[1], ka[2]);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, "kd"), kd[0], kd[1], kd[2]);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, "ks"), ks[0], ks[1], ks[2]);
    this.gl.uniform1f(this.gl.getUniformLocation(this.program, "shininess"), shininess);

  }

  MIT(MIT) {
    this.gl.useProgram(this.program);
    let modelViewITLocation3 = gl.getUniformLocation(this.program, "modelviewIT");
    this.gl.uniformMatrix4fv(modelViewITLocation3, false, MIT);
  }

  draw() {

    this.gl.useProgram(this.program);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.Vbuffer);
    this.gl.enableVertexAttribArray(this.Vpointer);
    this.gl.vertexAttribPointer(this.Vpointer, 4, this.gl.FLOAT, false, 0, 0);

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.Nbuffer);
    this.gl.vertexAttribPointer(this.vertexNormal, 3, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(this.vertexNormal);

    this.gl.activeTexture(this.gl.TEXTURE0);
    this.gl.bindTexture(this.gl.TEXTURE_2D, woodTextureImage);
    this.gl.uniform1i(this.gl.getUniformLocation(this.program, "texMap0"), 0);

    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.Ibuffer);

    this.gl.drawElements(this.gl.TRIANGLES, 3 * (this.points.indexList.length / 3), gl.UNSIGNED_SHORT, 0)
  }

  sendLightUniforms(name, Ia, Id, Is, dir) {
    this.gl.useProgram(this.program);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, name.concat("_Ia")), Ia[0], Ia[1], Ia[2]);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, name.concat("_Id")), Id[0], Id[1], Id[2]);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, name.concat("_Is")), Is[0], Is[1], Is[2]);
    this.gl.uniform3f(this.gl.getUniformLocation(this.program, name.concat("_dir")), dir[0], dir[1], dir[2]);
  }

  sendProjectionUniform(persp) {
    this.gl.useProgram(this.program);
    this.gl.uniformMatrix4fv(this.projectionLocation, false, persp);
  }

  texturing(imageUrl) {
    console.log("TEST")
    this.gl.useProgram(this.program);

    let textureImage = this.gl.createTexture();
    this.gl.bindTexture(this.gl.TEXTURE_2D, textureImage);
    const image = new Image();
    image.crossOrigin = "anonymous";
    var gl = this.gl
    image.onload = function() {
        gl.bindTexture( gl.TEXTURE_2D, textureImage );
        gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image );
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);        
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        //gl.generateMipmap( gl.TEXTURE_2D ); // only use this if the image is a power of 2
        return textureImage;
    };
    image.src = imageUrl;

    var textureVertexbuffer1 = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, textureVertexbuffer1);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, flatten(this.points.texCoords), this.gl.STATIC_DRAW);
    
    var textureCoordinate1 = this.gl.getAttribLocation(this.program,"textureCoordinate");
    this.gl.vertexAttribPointer(textureCoordinate1, 2, this.gl.FLOAT, false, 0, 0);
    this.gl.enableVertexAttribArray(textureCoordinate1);
  }
}

function getFaceNormals(vertices, indexList, numTriangles) {
    let faceNormals = [];
    for (let i = 0; i < numTriangles; i++) {
        let p0 = vertices[indexList[3 * i]];
        let p1 = vertices[indexList[3 * i + 1]];
        let p2 = vertices[indexList[3 * i + 2]];

        let v1 = vec3(p1[0] - p0[0], p1[1] - p0[1], p1[2] - p0[2])
        let v2 = vec3(p2[0] - p0[0], p2[1] - p0[1], p2[2] - p0[2])

        let n = cross(v1, v2);
        n = normalize(n);
        faceNormals.push(n);
    }

    // Following line returns the array of face normals
    return faceNormals;
}

function getVertexNormals(vertices, indexList, faceNormals, numVertices, numTriangles) {
    let vertexNormals = [];
    for (let j = 0; j < numVertices; j++) {
        let vertexNormal = vec3(.0, .0, .0);
        for (let i = 0; i < numTriangles; i++) {
            if (j == indexList[3 * i] || j == indexList[3 * i + 1] || j == indexList[3 * i + 2]) {
                vertexNormal[0] += faceNormals[i][0];
                vertexNormal[1] += faceNormals[i][1];
                vertexNormal[2] += faceNormals[i][2];
            }
        }

        if (length(vertexNormal) > 1e-6) {
            vertexNormal = normalize(vertexNormal);
        }
        vertexNormals.push(vertexNormal);
    }

    // Following line returns the array of vertex normals
    return vertexNormals;
}
